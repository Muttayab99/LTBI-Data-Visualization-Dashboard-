<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LTBI Data Visualization Dashboard</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      /* Dark theme (default) */
      --bg-color: #0a0c10;
      --section-bg: linear-gradient(145deg, #151920, #1a1f27);
      --text-color: #e6e8eb;
      --control-bg: rgba(255, 255, 255, 0.03);
      --border-color: rgba(255, 255, 255, 0.05);
      --tooltip-bg: rgba(24, 28, 36, 0.95);
    }

    :root[data-theme="light"] {
      --bg-color: #f5f7fa;
      --section-bg: linear-gradient(145deg, #ffffff, #f0f2f5);
      --text-color: #2c3e50;
      --control-bg: rgba(0, 0, 0, 0.03);
      --border-color: rgba(0, 0, 0, 0.05);
      --tooltip-bg: rgba(255, 255, 255, 0.95);
    }

    /* Theme toggle button styles */
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      background: var(--control-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-color);
      cursor: pointer;
      z-index: 1000;
      transition: all 0.3s ease;
    }

    .theme-toggle:hover {
      background: var(--border-color);
    }

    /* Update existing styles to use CSS variables */
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
    }

    .section {
      background: var(--section-bg);
      border: 1px solid var(--border-color);
    }

    .controls {
      background: var(--control-bg);
    }

    .tooltip {
      background: var(--tooltip-bg);
      border: 1px solid var(--border-color);
    }

    /* General Styles */
    body {
        font-family: 'Inter', 'Segoe UI', sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 0;
    }

    h1 {
        font-size: 2.8em;
        font-weight: 600;
        background: linear-gradient(90deg, #64b5f6, #2196f3);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        margin: 40px 0;
    }

    .dashboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
        gap: 30px;
        padding: 30px;
        max-width: 1400px;
        margin: 0 auto;
    }

    .section {
        background: var(--section-bg);
        border-radius: 16px;
        padding: 25px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        border: 1px solid var(--border-color);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .section:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
    }

    .controls {
        background: var(--control-bg);
        padding: 15px;
        border-radius: 12px;
        margin-bottom: 25px;
        backdrop-filter: blur(10px);
    }

    .controls label {
        font-weight: 500;
        color: #90caf9;
        margin-right: 12px;
    }

    .controls select, #file-input {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #fff;
        padding: 8px 12px;
        border-radius: 8px;
        transition: all 0.3s ease;
        cursor: pointer;
    }

    .controls select:hover, #file-input:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.2);
    }

    .tooltip {
        position: absolute;
        background: var(--tooltip-bg);
        color: #fff;
        padding: 10px;
        border-radius: 5px;
        pointer-events: none;
        z-index: 1000;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        max-width: 250px;
        word-wrap: break-word;
        border: 1px solid var(--border-color);
    }

    /* Visualization Specific Styles */
    .node {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    .node:hover {
        stroke: #64b5f6;
        stroke-width: 2px;
    }

    .link {
        stroke-opacity: 0.6;
        stroke-width: 1.5px;
    }

    .link {
        stroke: rgba(255, 255, 255, 0.1);
        transition: opacity 0.3s ease;
    }

    .treemap-cell {
        stroke: #0a0c10;
        transition: all 0.3s ease;
    }

    .treemap-cell:hover {
        stroke: #64b5f6;
        stroke-width: 2px;
        filter: brightness(1.2);
    }

    .node text {
        pointer-events: none;
        font-size: 10px;
    }

    .relationship-filter {
        margin-top: 10px;
    }

    /* Legend and Breadcrumb Styles */
    .legend {
        margin-top: 20px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
    }

    .breadcrumb {
        color: #90caf9;
        font-size: 14px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        margin-top: 15px;
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.02);
    }

    ::-webkit-scrollbar-thumb {
        background: rgba(144, 202, 249, 0.3);
        border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: rgba(144, 202, 249, 0.5);
    }

    #treemap-container {
        width: 100%;
        height: 600px; /* Set a fixed height */
        position: relative;
    }

    #tooltip {
        position: absolute;
        display: none;
        background: var(--tooltip-bg);
        backdrop-filter: blur(8px);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        font-size: 13px;
        line-height: 1.5;
        pointer-events: none;
        z-index: 10;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .dashboard {
            grid-template-columns: 1fr;
        }
    }

    .node circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }
    .link {
      stroke-opacity: 0.6;
    }
    .relationship-filter {
      margin-top: 10px;
    }
    /* Responsive Design Enhancements */
    @media (max-width: 600px) {
      .dashboard {
        grid-template-columns: 1fr;
      }
      .section {
        padding: 15px;
      }
    }
    /* Legend Styles */
    .interactive-legend {
      display: flex;
      flex-wrap: wrap;
      margin-top: 15px;
    }
    .legend-item {
      margin-right: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }
    .legend-color {
      width: 15px;
      height: 15px;
      margin-right: 5px;
      border-radius: 3px;
    }

    .animate-button {
      background: var(--bg-color);
      color: var(--text-color);
      border: 2px solid #2196f3;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 15px;
    }

    .animate-button:hover {
      background: #2196f3;
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
    }

    .animate-button.playing {
      background: #f44336;
      border-color: #f44336;
      color: white;
    }

    .animate-button.playing:hover {
      background: #d32f2f;
      border-color: #d32f2f;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .animate-button.playing {
      animation: pulse 2s infinite;
    }

    /* Add new heading styles */
    .section-heading {
      color: var(--text-color);
      font-size: 1.2em;
      margin-bottom: 15px;
      text-decoration: none;
      display: block;
      transition: color 0.3s ease;
    }

    .section-heading:hover {
      color: #2196f3;
    }
  </style>
</head>
<body>
  <button class="theme-toggle" id="themeToggle">🌓 Toggle Theme</button>
  <h1>LTBI Data Visualization Dashboard</h1>
  <div class="dashboard">
    <!-- Dynamic Graph with Filters -->
    <div class="section" id="dynamic-graph">
      <a href="force-directed-graph.html" class="section-heading">Network Relationships Between Countries</a>
      <div class="controls">
        <label for="nodeSizeMetric">Node Size Metric:</label>
        <select id="nodeSizeMetric">
          <option value="Average_Household_Size">Average Household Size</option>
          <option value="Metric">Metric</option>
        </select>
        <label for="relationshipType">Relationship Type:</label>
        <select id="relationshipType">
          <option value="WHO_Region">WHO Region</option>
          <option value="Region">Region</option>
          <option value="Subregion">Sub-region</option>
          <option value="Income_Level">Income Level</option>
        </select>
      </div>
      <div id="chart-graph"></div>
      <!-- Add Export Button -->
      <button id="exportGraphBtn">Export Graph</button>
      <div class="interactive-legend" id="graphLegend"></div>
    </div>

    <!-- Interactive Choropleth Map -->
    <div class="section" id="choropleth-map">
      <a href="map-chart.html" class="section-heading">Global Distribution of LTBI Cases</a>
      <div class="controls">
        <label for="year">Select Year: </label>
        <select id="year"></select>
      </div>
      <div id="map"></div>
      <div class="legend">
        <svg id="legend" width="600" height="60"></svg>
      </div>
    </div>

    <!-- Interactive Sunburst Chart -->
    <div class="section" id="sunburst-chart">
      <a href="sunburst.html" class="section-heading">Hierarchical Distribution of Cases by Region</a>
      <div class="controls">
        <label for="countryFilterSunburst">Select Country: </label>
        <select id="countryFilterSunburst">
          <option value="All">All</option>
        </select>
        <br/>
        <div class="color-scheme">
          <label for="colorScheme">Color Scheme:</label>
          <select id="colorScheme">
            <option value="interpolateBlues">Blues</option>
            <option value="interpolateLightBlue">Light Blues</option>
          </select>
        </div>
      </div>
      <div id="chart-sunburst"></div>
      <div class="breadcrumb" id="breadcrumb"></div>
    </div>

    <!-- Bar Chart Timeline Visualization -->
    <div class="section" id="bar-chart">
      <a href="timeline.html" class="section-heading">Timeline of Cases Over Years</a>
      <div class="controls">
        <label for="countryFilterBar">Select Country: </label>
        <select id="countryFilterBar">
          <option value="All">All</option>
        </select>
        <label for="metricFilter">Select Metric: </label>
        <select id="metricFilter">
          <option value="Estimated_Household_Contacts">Estimated Household Contacts</option>
          <option value="Prev_Treatment_Contacts_Pct">Previous Treatment Contacts (%)</option>
          <option value="Prev_Treatment_Kids_Pct">Previous Treatment Kids (%)</option>
        </select>
      </div>
      <div id="chart-bar" style="width: 100%; height: 100%;"></div>
    </div>

    <!-- Hierarchical Treemap -->
    <div class="section" id="treemap">
      <a href="Tree.html" class="section-heading">Hierarchical View of Regional Distribution</a>
      <div id="treemap-container"></div>
      <div id="tooltip" class="tooltip" style="display: none;"></div>
    </div>

    <!-- New Bar Graph Visualization Section -->
    <div class="section" id="top-countries-bar-chart">
      <a href="Top_X_BarGraph.html" class="section-heading">Top Countries Comparison</a>
      <div class="controls">
        <label for="topXSelect">Select Top X Countries: </label>
        <select id="topXSelect">
          <option value="5">Top 5</option>
          <option value="10" selected>Top 10</option>
          <option value="15">Top 15</option>
          <option value="20">Top 20</option>
        </select>
        <label for="yearRange">Select Year: </label>
        <input type="range" id="yearRange" min="2000" max="2023" value="2000" step="1">
        <span id="yearLabel">2000</span>
        <button id="animateButton" class="animate-button">
          <span class="icon">▶</span>
          <span class="text">Animate Years</span>
        </button>
      </div>
      <div id="top-countries-chart"></div>
    </div>
  </div>

  <script>
    // Add this at the start of your script section
    // Theme switching functionality
    const themeToggle = document.getElementById('themeToggle');
    const root = document.documentElement;
    
    // Load saved theme preference
    const savedTheme = localStorage.getItem('theme') || 'dark';
    root.setAttribute('data-theme', savedTheme);

    themeToggle.addEventListener('click', () => {
      const currentTheme = root.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      root.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      // Update visualizations if needed
      // You might need to update colors for better contrast in light mode
      if (window.updateVisualizationsTheme) {
        window.updateVisualizationsTheme(newTheme);
      }
    });

    // Function to update visualization colors based on theme
    window.updateVisualizationsTheme = (theme) => {
      const lightColors = [
        "#2196f3", // Bright Blue
        "#1976d2", // Medium Blue
        "#0d47a1", // Dark Blue
        "#64b5f6", // Light Blue
        "#90caf9", // Very Light Blue
        "#42a5f5", // Sky Blue
        "#1e88e5", // Strong Blue
        "#0d47a1", // Navy Blue
        "#5c6bc0", // Indigo
        "#3949ab"  // Deep Blue
      ];

      const darkColors = blueColorScheme; // Your existing dark theme colors

      const colors = theme === 'light' ? lightColors : darkColors;
      
      // Update color scales for all visualizations
      if (colorSunburst) colorSunburst.range(colors);
      if (colorScale) colorScale.range(colors);
      
      // Trigger rerender of visualizations if needed
      // Add calls to your visualization update functions here
    };

    // Update the blueColorScheme at the start of the script with more contrasting shades
    const blueColorScheme = [
        "#001f3f", // Dark Navy
        "#034694", // Royal Blue
        "#0066cc", // Strong Blue
        "#0088ff", // Bright Blue
        "#40a9ff", // Light Blue
        "#69c0ff", // Sky Blue
        "#91d5ff", // Baby Blue
        "#bae7ff", // Pale Blue
        "#e6f7ff", // Very Pale Blue
        "#f0f9ff"  // Almost White Blue
    ];

    // Global variable to store the selected country
    let selectedCountry = null;

    // Function to update selected country and notify visualizations
    function updateSelectedCountry(country) {
      selectedCountry = country;
      // Save selected country to localStorage
      localStorage.setItem('selectedCountry', country);
      // Trigger custom event for other visualizations
      const event = new CustomEvent('countrySelected', { detail: country });
      window.dispatchEvent(event);
    }

    // Load selected country from localStorage
    const savedCountry = localStorage.getItem('selectedCountry');
    if (savedCountry) {
      selectedCountry = savedCountry;
      const event = new CustomEvent('countrySelected', { detail: selectedCountry });
      window.dispatchEvent(event);
    }

    // Define a single tooltip element for all visualizations
    const tooltip = d3.select("#tooltip");

    // Dynamic Graph with Filters
    const widthGraph = 800;
    const heightGraph = 600;

    const svgGraph = d3.select("#chart-graph")
      .append("svg")
      .attr("viewBox", `0 0 ${widthGraph} ${heightGraph}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    // Add zoom behavior
    const zoomBehavior = d3.zoom()
      .scaleExtent([0.1, 4])
      .on("zoom", (event) => {
        graphContainer.attr("transform", event.transform);
      });

    svgGraph.call(zoomBehavior);

    const graphContainer = svgGraph.append("g");

    // Implement Dashboard State Persistence
    let savedSettings = JSON.parse(localStorage.getItem('dashboardSettings')) || {};

    d3.csv("processed_LTBI_dataset.csv").then(data => {
      // Preprocess data
      const nodes = [];
      const nodeMap = new Map();
      const links = [];
      const relationshipTypes = ["WHO_Region", "Region", "Subregion", "Income_Level"];
      const edgeColors = d3.scaleOrdinal(d3.schemeCategory10);

      // Function to create nodes and edges based on selected relationship
      function updateGraph(nodeSizeMetric, relationshipType) {
        nodes.length = 0;
        links.length = 0;
        nodeMap.clear();

        // Create nodes
        data.forEach(d => {
          if (!nodeMap.has(d.Country)) {
            nodeMap.set(d.Country, {
              id: d.Country,
              group: d.WHO_Region,
              sizeMetric: +d[nodeSizeMetric] || 1,
              info: {
                Region: d.Region,
                Subregion: d['Sub-region'],
                Income_Level: d['Income Level'],
                Average_Household_Size: +d.Average_Household_Size || 0,
                Metric: +d.Metric || 0
              }
            });
          }
        });

        nodes.push(...nodeMap.values());

        // Create edges
        nodes.forEach(sourceNode => {
          nodes.forEach(targetNode => {
            if (sourceNode !== targetNode && sourceNode.info[relationshipType] === targetNode.info[relationshipType]) {
              links.push({
                source: sourceNode.id,
                target: targetNode.id,
                type: relationshipType
              });
            }
          });
        });

        renderGraph(nodeSizeMetric, relationshipType);
      }

      // Render the graph
      function renderGraph(nodeSizeMetric, relationshipType) {
        graphContainer.selectAll('*').remove();

        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links)
            .id(d => d.id)
            .distance(50))
          .force("charge", d3.forceManyBody().strength(-50))
          .force("center", d3.forceCenter(widthGraph / 2, heightGraph / 2))
          .force("collision", d3.forceCollide().radius(d => d.size));

        // Create links
        const link = graphContainer.append("g")
          .attr("stroke", "#999")
          .attr("stroke-opacity", 0.6)
          .selectAll("line")
          .data(links)
          .enter().append("line")
          .attr("stroke", d => edgeColors(relationshipTypes.indexOf(d.type)));

        // Create nodes
        const node = graphContainer.append("g")
          .attr("stroke", "#fff")
          .attr("stroke-width", 1.5)
          .selectAll("g")
          .data(nodes)
          .enter().append("g")
          .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        node.append("circle")
          .attr("r", d => d.sizeMetric)
          .attr("fill", d => edgeColors(relationshipTypes.indexOf("WHO_Region") + d.group));

        node.append("title")
          .text(d => `${d.id}
Region: ${d.info.Region}
Sub-region: ${d.info.Subregion}
Income Level: ${d.info.Income_Level}
Average Household Size: ${d.info.Average_Household_Size}
Metric: ${d.info.Metric}`);

        node.on("mouseover", function(event, d) {
            tooltip.style("display", "block")
              .html(`<strong>${d.id}</strong><br>
Region: ${d.info.Region}<br>
Sub-region: ${d.info.Subregion}<br>
Income Level: ${d.info.Income_Level}<br>
Average Household Size: ${d.info.Average_Household_Size}<br>
Metric: ${d.info.Metric}<br>
Connected Countries: ${links.filter(l => l.source.id === d.id || l.target.id === d.id).length}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", function() {
            tooltip.style("display", "none");
          })
          .on("click", function(event, d) {
            updateSelectedCountry(d.id);
          });

        simulation.on("tick", () => {
          link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          node
            .attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Update function for filtering
        function updateVisibility() {
          const selectedRelationship = relationshipTypeSelect.node().value;
          const selectedNodeSizeMetric = nodeSizeMetricSelect.node().value;
          updateGraph(selectedNodeSizeMetric, selectedRelationship);
          saveSettings();
        }

        relationshipTypeSelect.on("change", updateVisibility);
        nodeSizeMetricSelect.on("change", updateVisibility);
      }

      // Drag functions
      function dragstarted(event) {
        if (!event.active) event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) {
          event.subject.fx = null;
          event.subject.fy = null;
        }
      }

      // Setup filters
      const nodeSizeMetricSelect = d3.select("#nodeSizeMetric");
      const relationshipTypeSelect = d3.select("#relationshipType");

      updateGraph(nodeSizeMetricSelect.node().value, relationshipTypeSelect.node().value);

      // Handle country selection events
      window.addEventListener('countrySelected', (e) => {
        const country = e.detail;
        graphContainer.selectAll("circle")
          .attr("stroke-width", d => d.id === country ? 3 : 1.5)
          .attr("stroke", d => d.id === country ? "#ff0" : "#fff");
      });

      // Implement Advanced Filtering Options
      const filterControls = d3.select(".controls").append("div").attr("class", "filter-controls");
      filterControls.append("label").text("Minimum Metric Value:");
      filterControls.append("input").attr("type", "number").attr("id", "minMetricValue").attr("value", savedSettings.minMetricValue || 0);

      // Implement Dynamic and Interactive Legend
      const legend = d3.select("#graphLegend");
      const regions = Array.from(new Set(data.map(d => d.WHO_Region)));
      const colorScale = d3.scaleOrdinal(d3.schemeCategory10).domain(regions);

      regions.forEach(region => {
        const legendItem = legend.append("div").attr("class", "legend-item");
        legendItem.append("div")
          .attr("class", "legend-color")
          .style("background-color", colorScale(region));
        legendItem.append("span").text(region);
        legendItem.on("click", () => {
          // Toggle visibility
          const isActive = !legendItem.classed("inactive");
          legendItem.classed("inactive", isActive);
          graphContainer.selectAll("circle")
            .filter(d => d.group === region)
            .transition().duration(500)
            .style("opacity", isActive ? 0 : 1);
        });
      });

      // Save settings to localStorage
      function saveSettings() {
        const settings = {
          nodeSizeMetric: nodeSizeMetricSelect.node().value,
          relationshipType: relationshipTypeSelect.node().value,
          minMetricValue: d3.select("#minMetricValue").node().value
        };
        localStorage.setItem('dashboardSettings', JSON.stringify(settings));
      }

      // Load saved settings
      if (savedSettings.nodeSizeMetric) {
        nodeSizeMetricSelect.node().value = savedSettings.nodeSizeMetric;
      }
      if (savedSettings.relationshipType) {
        relationshipTypeSelect.node().value = savedSettings.relationshipType;
      }

      // Implement Export Functionality
      d3.select("#exportGraphBtn").on("click", function() {
        const svgData = new XMLSerializer().serializeToString(svgGraph.node());
        const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(svgBlob);
        const downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = "graph_export.svg";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      });
    }).catch(error => console.error("Error loading or processing data:", error));

    // Interactive Choropleth Map
    const widthMap = 1400;
    const heightMap = 700;
    const mapDiv = d3.select("#map");
    const svgMap = mapDiv.append("svg")
      .attr("width", "100%")
      .attr("height", "90%")
      .attr("viewBox", `0 0 ${widthMap} ${heightMap}`)
      .attr("preserveAspectRatio", "xMidYMid meet");

    const projection = d3.geoNaturalEarth1()
      .scale(250)
      .translate([widthMap / 2, heightMap / 2]);
    const path = d3.geoPath().projection(projection);

    const colorScaleLow = d3.scaleSequential(d3.interpolateBlues).domain([0, 120000]);

    const zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on("zoom", (event) => {
        gMap.attr("transform", event.transform);
      });

    svgMap.call(zoom);

    const gMap = svgMap.append("g");

    Promise.all([
      d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
      d3.csv("processed_LTBI_dataset.csv")
    ]).then(([geojson, data]) => {
      const years = Array.from(new Set(data.map(d => +d.Year))).sort((a, b) => a - b);

      const yearSelect = d3.select("#year");
      years.forEach(year => {
        yearSelect.append("option").text(year).attr("value", year);
      });

      yearSelect.on("change", () => updateMap(+yearSelect.node().value));
      updateMap(years[0]);

      function updateMap(year) {
        const yearData = data.filter(d => +d.Year === year);
        const dataByISO = new Map(yearData.map(d => [d.ISO3, +d.Metric]));

        gMap.selectAll("path").remove();
        gMap.selectAll("path")
          .data(geojson.features)
          .join("path")
          .attr("d", path)
          .attr("fill", d => {
            const value = dataByISO.get(d.id);
            return value === undefined ? "#ccc" : colorScaleLow(value);
          })
          .attr("stroke", "#333")
          .on("mouseover", function (event, d) {
            const value = dataByISO.get(d.id);
            tooltip.style("display", "block")
              .html(`<strong>${d.properties.name}</strong><br>Estimated Contacts: ${value || "No data"}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.style("display", "none"))
          .on("click", function (event, d) {
            const [[x0, y0], [x1, y1]] = path.bounds(d);
            svgMap.transition().duration(1000).call(
              zoom.transform,
              d3.zoomIdentity
                .translate(widthMap / 2, heightMap / 2)
                .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / widthMap, (y1 - y0) / heightMap)))
                .translate(-(x0 + x1) / 2, -(y0 + y1) / 2)
            );
            updateSelectedCountry(d.properties.name);
          });

        // Highlight based on selectedCountry
        window.addEventListener('countrySelected', (e) => {
          const country = e.detail;
          gMap.selectAll("path")
            .attr("fill-opacity", d => (country === null || d.properties.name === country) ? 1 : 0.3);
        });

        updateLegend();
      }

      function updateLegend() {
        const legendWidth = 500;
        const legendHeight = 20;

        const legendSvg = d3.select("#legend");
        legendSvg.selectAll("*").remove();

        const gradientLow = legendSvg.append("defs")
          .append("linearGradient")
          .attr("id", "gradientLow")
          .attr("x1", "0%")
          .attr("x2", "100%");

        gradientLow.append("stop")
          .attr("offset", "0%")
          .attr("stop-color", colorScaleLow(0));

        gradientLow.append("stop")
          .attr("offset", "100%")
          .attr("stop-color", colorScaleLow(120000));

        legendSvg.append("rect")
          .attr("width", legendWidth)
          .attr("height", legendHeight)
          .style("fill", "url(#gradientLow)")
          .attr("x", 0)
          .attr("y", 10);

        const legendScaleLow = d3.scaleLinear().domain([0, 120000]).range([0, legendWidth]);

        const legendAxisLow = d3.axisBottom(legendScaleLow).ticks(5).tickSize(10);

        legendSvg.append("g")
          .attr("transform", `translate(0, ${30})`)
          .call(legendAxisLow);
      }
    });

    // Interactive Sunburst Chart
    const widthSunburst = 700;
    const heightSunburst = 700;
    const radius = Math.min(widthSunburst, heightSunburst) / 2;

    const svgSunburst = d3.select("#chart-sunburst")
      .append("svg")
      .attr("viewBox", "0 0 700 700")
      .attr("preserveAspectRatio", "xMidYMid meet")
      .classed("svg-content-responsive", true)
      .append("g")
      .attr("transform", `translate(${widthSunburst / 2},${heightSunburst / 2})`);

    const colorSunburst = d3.scaleOrdinal(blueColorScheme);

    let currentColorScheme = "schemeCategory10";

    d3.csv("processed_LTBI_dataset.csv").then(data => {
      data.forEach(d => d.Metric = +d.Metric);

      const countries = Array.from(new Set(data.map(d => d.Country)));
      const countryFilter = d3.select("#countryFilterSunburst");
      countries.forEach(country => {
        countryFilter.append("option").text(country).attr("value", country);
      });

      function renderChart(filteredData) {
        const nestedData = d3.group(filteredData, d => d.Country, d => d.Year);

        const root = d3.hierarchy({ name: "World", children: Array.from(nestedData, ([country, years]) => ({
            name: country,
            children: Array.from(years, ([year, records]) => ({
              name: year,
              value: d3.sum(records, r => r.Metric)
            }))
          }))
        });

        const partition = d3.partition().size([2 * Math.PI, radius])(root.sum(d => d.value));

        const arc = d3.arc()
          .startAngle(d => d.x0)
          .endAngle(d => d.x1)
          .innerRadius(d => d.y0)
          .outerRadius(d => d.y1);

        svgSunburst.selectAll("path").remove();
        svgSunburst.selectAll("path")
          .data(partition.descendants().slice(1))
          .join("path")
          .attr("d", arc)
          .style("fill", d => colorSunburst((d.children ? d : d.parent).data.name))
          .style("stroke", "#fff")
          .style("opacity", 1)
          .on("mouseover", function (event, d) {
            svgSunburst.selectAll("path").style("opacity", 0.3);
            d3.select(this).style("opacity", 1);
            tooltip.style("display", "block")
              .html(`<strong>${d.data.name}</strong><br>Value: ${d.value || "No data"}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", function () {
            svgSunburst.selectAll("path").style("opacity", 1);
            tooltip.style("display", "none");
          })
          .on("click", function (event, d) {
            updateBreadcrumbs(d);
            if (d.depth === 1) { // Assuming depth 1 is country level
              updateSelectedCountry(d.data.name);
            } else {
              updateSelectedCountry(null);
            }
          });

        // Highlight based on selectedCountry
        window.addEventListener('countrySelected', (e) => {
          const country = e.detail;
          svgSunburst.selectAll("path")
            .attr("opacity", d => (country === null || d.data.name === country) ? 1 : 0.3);
        });

        function updateBreadcrumbs(node) {
          const trail = [];
          let current = node;
          while (current.parent) {
            trail.unshift(current.data.name);
            current = current.parent;
          }
          const breadcrumb = d3.select("#breadcrumb");
          breadcrumb.html("");
          trail.forEach((name, index) => {
            const link = breadcrumb.append("span").text(name);
            if (index < trail.length - 1) {
              breadcrumb.append("span").text(" > ");
            }
            link.style("cursor", "pointer").on("click", () => {
              // Navigate to the selected level
              renderChart(data.filter(d => d.Country === name || name === "World"));
            });
          });
        }

        svgSunburst.selectAll("path").style("cursor", "pointer");

        // Smooth Animations for Sunburst Transitions
        svgSunburst.selectAll("path")
          .transition()
          .duration(750)
          .attrTween("d", arcTween);

        function arcTween(d) {
          const i = d3.interpolate(this.current, d);
          this.current = i(0);
          return (t) => arc(i(t));
        }
      }

      renderChart(data);

      countryFilter.on("change", function () {
        const selectedCountry = this.value;
        const filteredData = selectedCountry === "All" ? data : data.filter(d => d.Country === selectedCountry);
        renderChart(filteredData);
      });

      d3.select("#colorScheme").on("change", function () {
        const scheme = this.value;
        const colors = scheme === "interpolateBlues" ?
            Array.from({length: 10}, (_, i) => d3.interpolateBlues(i / 9)) :
            Array.from({length: 10}, (_, i) => d3.interpolateLightBlue(i / 9));
        colorSunburst.range(colors);
        renderChart(data);
      });
    }).catch(error => {
      console.error("Error loading or processing data:", error);
    });

    // Bar Chart Timeline Visualization
    const widthBar = document.getElementById('chart-bar').clientWidth;
    const heightBar = document.getElementById('chart-bar').clientHeight;
    const margin = { top: 20, right: 30, bottom: 50, left: 60 };

    const svgBar = d3.select("#chart-bar")
      .append("svg")
      .attr("viewBox", `0 0 ${widthBar} ${heightBar}`)
      .attr("preserveAspectRatio", "xMidYMid meet")
      .classed("svg-content-responsive", true);

    d3.csv("processed_LTBI_dataset.csv").then(data => {
      data.forEach(d => {
        d.Year = +d.Year || 0;
        d.Estimated_Household_Contacts = +d.Estimated_Household_Contacts || 0;
        d.Prev_Treatment_Contacts_Pct = +d.Prev_Treatment_Contacts_Pct || 0;
        d.Prev_Treatment_Kids_Pct = +d.Prev_Treatment_Kids_Pct || 0;
      });

      const countries = Array.from(new Set(data.map(d => d.Country)));
      const countryFilter = d3.select("#countryFilterBar");
      countries.forEach(country => {
        countryFilter.append("option").text(country).attr("value", country);
      });

      const colorScale = d3.scaleSequential(d3.interpolateBlues)
        .domain([0, data.length]);

      function renderChart(filteredData, metric) {
        svgBar.selectAll("*").remove();

        if (filteredData.length === 0) {
          console.warn("No data available for the selected filter");
          return;
        }

        if (!filteredData.some(d => typeof d[metric] === "number" && !isNaN(d[metric]) && d[metric] > 0)) {
          console.warn(`No valid data found for metric: ${metric}`);
          return;
        }

        const x = d3.scaleBand()
          .domain(filteredData.map(d => d.Year))
          .range([margin.left, widthBar - margin.right])
          .padding(0.2);

        const maxValue = d3.max(filteredData, d => d[metric]) || 0;
        const y = d3.scaleLinear()
          .domain([0, maxValue])
          .nice()
          .range([heightBar - margin.bottom, margin.top]);

        svgBar.append("g")
          .attr("transform", `translate(0,${heightBar - margin.bottom})`)
          .call(d3.axisBottom(x).tickFormat(d3.format("d")))
          .attr("font-size", "12px");

        svgBar.append("g")
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y))
          .attr("font-size", "12px");

        svgBar.selectAll(".bar")
          .data(filteredData)
          .join("rect")
          .attr("class", "bar")
          .attr("x", d => x(d.Year))
          .attr("y", d => y(d[metric]))
          .attr("width", x.bandwidth())
          .attr("height", d => heightBar - margin.bottom - y(d[metric]))
          .attr("fill", (d, i) => colorScale(i))
          .on("mouseover", function (event, d) {
            tooltip.style("display", "block")
              .html(`<strong>${d.Country} (${d.Year})</strong><br>${metric}: ${d[metric]}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", function () {
            tooltip.style("display", "none");
          })
          .on("click", function (event, d) {
            updateSelectedCountry(d.Country === selectedCountry ? null : d.Country);
          });

        window.addEventListener('countrySelected', (e) => {
          const country = e.detail;
          svgBar.selectAll(".bar")
            .attr("opacity", d => (country === null || d.Country === country) ? 1 : 0.3);
        });
      }

      renderChart(data, "Estimated_Household_Contacts");

      d3.select("#countryFilterBar").on("change", function () {
        const selectedCountry = this.value;
        const selectedMetric = d3.select("#metricFilter").property("value");
        const filteredData = selectedCountry === "All" ? data : data.filter(d => d.Country === selectedCountry);
        renderChart(filteredData, selectedMetric);
      });

      d3.select("#metricFilter").on("change", function () {
        const selectedCountry = d3.select("#countryFilterBar").property("value");
        const selectedMetric = this.value;
        const filteredData = selectedCountry === "All" ? data : data.filter(d => d.Country === selectedCountry);
        const sortedData = filteredData.sort((a, b) => b[selectedMetric] - a[selectedMetric]);
        renderChart(sortedData, selectedMetric);
      });

    }).catch(error => {
      console.error("Error loading or processing data:", error);
    });

    // Hierarchical Treemap
    function prepareHierarchicalData(data) {
      const hierarchy = {
        name: "Root",
        children: []
      };

      const levels = ['Region', 'Sub-region', 'Country'];

      data.forEach(item => {
        let currentLevel = hierarchy;
        levels.forEach((levelKey, index) => {
          const levelValue = item[levelKey];

          if (!currentLevel.children) {
            currentLevel.children = [];
          }

          let levelGroup = currentLevel.children.find(
            child => child.name === levelValue
          );

          if (!levelGroup) {
            levelGroup = {
              name: levelValue,
              children: []
            };
            currentLevel.children.push(levelGroup);
          }

          if (index === levels.length - 1) {
            const metricValue = parseFloat(item['Metric']) || 0;
            levelGroup.value = metricValue;

            levelGroup.metadata = {
              Year: item['Year'],
              'Income Level': item['Income Level'],
              ISO3: item['ISO3']
            };
          }

          currentLevel = levelGroup;
        });
      });

      return hierarchy;
    }

    function createTreemap(data) {
      const container = d3.select("#treemap-container");
      container.selectAll("*").remove();

      const width = container.node().clientWidth;
      const height = container.node().clientHeight;

      const svg = container
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      const color = d3.scaleOrdinal(blueColorScheme);

      const treemap = d3.treemap()
        .size([width, height])
        .padding(1)
        .round(true);

      const root = d3.hierarchy(data)
        .sum(d => d.value || 0)
        .sort((a, b) => (b.value || 0) - (a.value || 0));

      treemap(root);

      svg.selectAll(".treemap-cell")
        .data(root.leaves())
        .enter().append("rect")
        .attr("class", "treemap-cell")
        .attr("x", d => d.x0)
        .attr("y", d => d.y0)
        .attr("width", d => d.x1 - d.x0)
        .attr("height", d => d.y1 - d.y0)
        .attr("fill", d => color(d.parent.parent.data.name))
        .on("mouseover", function(event, d) {
          const metadata = d.data.metadata || {};
          tooltip.style("display", "block")
            .html(`
              <strong>Name:</strong> ${d.data.name}<br>
              <strong>Value:</strong> ${d.data.value}<br>
              <strong>Year:</strong> ${metadata.Year || 'N/A'}<br>
              <strong>Income Level:</strong> ${metadata['Income Level'] || 'N/A'}<br>
              <strong>Sub-region:</strong> ${d.parent.data.name}<br>
              <strong>Region:</strong> ${d.parent.parent.data.name}
            `)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px");
        })
        .on("mouseout", function() {
          tooltip.style("display", "none");
        })
        .on("click", function(event, d) {
          const country = d.data.metadata.ISO3; // Adjust based on actual data
          updateSelectedCountry(country);
        });

      // Highlight based on selectedCountry
      window.addEventListener('countrySelected', (e) => {
        const country = e.detail;
        svg.selectAll(".treemap-cell")
          .attr("opacity", d => (country === null || d.data.name === country) ? 1 : 0.3);
      });

      svg.selectAll(".treemap-label")
        .data(root.leaves())
        .enter().append("text")
        .attr("class", "treemap-label")
        .attr("x", d => (d.x0 + d.x1) / 2)
        .attr("y", d => (d.y0 + d.y1) / 2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .text(d => d.data.name)
        .attr("pointer-events", "none")
        .call(function(text) {
          text.each(function(d) {
            const self = d3.select(this);
            const textLength = self.node().getComputedTextLength();
            const rectWidth = d.x1 - d.x0;
            const rectHeight = d.y1 - d.y0;

            if (textLength > rectWidth || self.node().getBBox().height > rectHeight) {
              self.remove();
            }
          });
        });
    }

    d3.csv("processed_LTBI_dataset.csv").then(data => {
      const hierarchicalData = prepareHierarchicalData(data);
      createTreemap(hierarchicalData);
    }).catch(error => {
      console.error("Error loading or processing data:", error);
    });

    window.addEventListener('resize', () => {
      const container = document.getElementById('treemap-container');
      if (container.children.length > 0) {
        createTreemap(window.lastProcessedData);
      }
    });

    // New Bar Graph Visualization Script
    d3.csv("processed_LTBI_dataset.csv").then(data => {
      // Prepare data
      data.forEach(d => {
        d.Year = +d.Year;
        d.Metric = +d.Metric;
      });

      const years = Array.from(new Set(data.map(d => d.Year))).sort((a, b) => a - b);
      const colorScale = d3.scaleOrdinal(blueColorScheme);

      const margin = { top: 20, right: 30, bottom: 50, left: 150 };
      const width = 800 - margin.left - margin.right;
      const height = 500 - margin.top - margin.bottom;

      const svg = d3.select("#top-countries-chart")
        .append("svg")
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const xScale = d3.scaleLinear()
        .range([0, width]);

      const yScale = d3.scaleBand()
        .range([0, height])
        .padding(0.1);

      const xAxis = svg.append("g")
        .attr("transform", `translate(0,0)`);

      const yAxis = svg.append("g");

      function updateChart(year, topX) {
        const filteredData = data.filter(d => d.Year === year);
        const topCountries = filteredData.sort((a, b) => b.Metric - a.Metric).slice(0, topX);

        xScale.domain([0, d3.max(topCountries, d => d.Metric)]);
        yScale.domain(topCountries.map(d => d.Country));

        xAxis.transition().duration(500).call(d3.axisTop(xScale).ticks(5));
        yAxis.transition().duration(500).call(d3.axisLeft(yScale));

        // DATA JOIN
        const bars = svg.selectAll(".bar")
          .data(topCountries, d => d.Country);

        // EXIT
        bars.exit()
          .transition().duration(500)
          .attr("width", 0)
          .remove();

        // UPDATE
        bars.transition().duration(500)
          .attr("y", d => yScale(d.Country))
          .attr("width", d => xScale(d.Metric))
          .attr("height", yScale.bandwidth());

        // ENTER
        bars.enter().append("rect")
          .attr("class", "bar")
          .attr("y", d => yScale(d.Country))
          .attr("width", 0)
          .attr("height", yScale.bandwidth())
          .attr("fill", d => colorScale(d.Country))
          .on("click", (event, d) => showCountryDetails(d.Country))
          .on("mouseover", function(event, d) {
            tooltip.style("display", "block")
              .html(`<strong>${d.Country}</strong><br>Year: ${d.Year}<br>Metric: ${d.Metric}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", () => tooltip.style("display", "none"))
          .transition().duration(500)
          .attr("width", d => xScale(d.Metric));
      }

      // Function to show detailed bar chart for a country
      function showCountryDetails(country) {
        const countryData = data.filter(d => d.Country === country);
        // Create a modal or a new section to display the detailed bar chart for the country
        // For simplicity, we'll log the country data to console
        console.log(`Detailed data for ${country}:`, countryData);
        // You can implement a modal or redirect to a detailed view as needed
      }

      // Handle year range input change
      const yearRange = d3.select("#yearRange");
      const yearLabel = d3.select("#yearLabel");
      yearRange.attr("min", d3.min(years)).attr("max", d3.max(years)).attr("value", d3.min(years));

      yearRange.on("input", function() {
        const selectedYear = +this.value;
        yearLabel.text(selectedYear);
        const topX = +d3.select("#topXSelect").node().value;
        updateChart(selectedYear, topX);
      });

      // Handle top X selection change
      d3.select("#topXSelect").on("change", function() {
        const selectedYear = +yearRange.node().value;
        const topX = +this.value;
        updateChart(selectedYear, topX);
      });

      let isAnimating = false;
      let animationTimer = null;

      // Add animation control function
      function toggleAnimation() {
        const button = d3.select("#animateButton");
        
        if (isAnimating) {
          // Stop animation
          if (animationTimer) clearInterval(animationTimer);
          button.html('<span class="icon">▶</span><span class="text">Animate Years</span>')
            .classed("playing", false);
          isAnimating = false;
        } else {
          // Start animation
          button.html('<span class="icon">⏹</span><span class="text">Stop Animation</span>')
            .classed("playing", true);
          isAnimating = true;
          
          let currentYear = +yearRange.node().value;
          const maxYear = +yearRange.attr("max");
          const minYear = +yearRange.attr("min");
          
          // Update every second
          animationTimer = setInterval(() => {
            currentYear++;
            if (currentYear > maxYear) {
              currentYear = minYear;
            }
            
            yearRange.node().value = currentYear;
            yearLabel.text(currentYear);
            updateChart(currentYear, +d3.select("#topXSelect").node().value);
          }, 1000);
        }
      }

      // Add click handler for animation button
      d3.select("#animateButton").on("click", toggleAnimation);

      // Modify existing event handlers to stop animation when manually changing values
      yearRange.on("input", function() {
        if (isAnimating) toggleAnimation(); // Stop animation if running
        const selectedYear = +this.value;
        yearLabel.text(selectedYear);
        const topX = +d3.select("#topXSelect").node().value;
        updateChart(selectedYear, topX);
      });

      d3.select("#topXSelect").on("change", function() {
        if (isAnimating) toggleAnimation(); // Stop animation if running
        const selectedYear = +yearRange.node().value;
        const topX = +this.value;
        updateChart(selectedYear, topX);
      });

      // Clean up animation when leaving the page
      window.addEventListener('beforeunload', () => {
        if (animationTimer) clearInterval(animationTimer);
      });

      // Initialize chart
      const initialYear = +yearRange.node().value;
      const initialTopX = +d3.select("#topXSelect").node().value;
      updateChart(initialYear, initialTopX);
    }).catch(error => console.error("Error loading or processing data:", error));
  </script>
</body>
</html>
